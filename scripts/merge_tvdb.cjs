/*
  Merge TVDB episodes into src/merged_hot_ones.json safely.

  Rules:
  - Add new regular episodes from TVDB by SxxEyy code if missing.
  - Add new specials from TVDB and auto-assign incremental label "SPECIAL 0xNNN".
  - Preserve existing entries, including custom types like "wing_pong" and existing guest arrays.
  - Do not overwrite existing records; just append missing ones.
  - Sort final output by date to maintain chronological order.

  Usage:
    node scripts/merge_tvdb.cjs

  Requires: CHECK_DATA/tvdb_hot_ones.json (generated by fetch_tvdb.cjs)
*/

const fs = require("fs");
const path = require("path");

function readJson(filePath) {
  const text = fs.readFileSync(filePath, "utf-8");
  return JSON.parse(text);
}

function writeJson(filePath, data) {
  fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
}

function parseDate(d) {
  const dt = new Date(d);
  return isNaN(dt.getTime()) ? null : dt;
}

function sortByDateChrono(a, b) {
  const da = parseDate(a.date);
  const db = parseDate(b.date);
  if (da && db) return da - db;
  if (da && !db) return -1;
  if (!da && db) return 1;
  return 0;
}

function main() {
  const root = process.cwd();
  const tvdbPath = path.join(root, "CHECK_DATA", "tvdb_hot_ones.json");
  const mergedPath = path.join(root, "src", "merged_hot_ones.json");

  if (!fs.existsSync(tvdbPath)) {
    console.error("Missing CHECK_DATA/tvdb_hot_ones.json. Run fetch first.");
    process.exit(1);
  }
  if (!fs.existsSync(mergedPath)) {
    console.error("Missing src/merged_hot_ones.json.");
    process.exit(1);
  }

  const tvdb = readJson(tvdbPath);
  const current = readJson(mergedPath);

  const existingEpisodeCodes = new Set(current.map((e) => e.episode));
  const existingByDate = new Map(current.map((e) => [e.date, e]));

  // Regulars: add if episode code not present
  const regularsToAdd = tvdb
    .filter((e) => e.episode_type === "regular")
    .filter((e) => !existingEpisodeCodes.has(e.episode));

  // Specials: add if no record exists for the same date; assign next 0x code
  const specialHexValues = current
    .filter(
      (e) => e.episode_type === "special" && typeof e.episode === "string"
    )
    .map((e) => {
      const m = /^SPECIAL\s+0x([0-9A-Fa-f]+)$/.exec(e.episode);
      if (!m) return null;
      return parseInt(m[1], 16);
    })
    .filter((n) => Number.isFinite(n));
  const maxHex = specialHexValues.length
    ? Math.max(...specialHexValues)
    : 0x000;
  const hexWidth = Math.max(
    3,
    ...current
      .map((e) => {
        const m = /^SPECIAL\s+0x([0-9A-Fa-f]+)$/.exec(e.episode || "");
        return m ? m[1].length : 0;
      })
      .filter((l) => l > 0)
  );
  let nextHex = maxHex + 1;

  const specialsToAdd = tvdb
    .filter((e) => e.episode_type === "special")
    .filter((e) => !existingByDate.has(e.date))
    .map((e) => {
      const code = nextHex.toString(16).toUpperCase().padStart(hexWidth, "0");
      nextHex += 1;
      return {
        season: e.season,
        episode: `SPECIAL 0x${code}`,
        date: e.date,
        guestDescription: e.guestDescription,
        guest: e.guest || [],
        episode_type: "special",
      };
    });

  const toAdd = [...regularsToAdd, ...specialsToAdd];

  if (toAdd.length === 0) {
    console.log("No new episodes to add from TVDB.");
    return;
  }

  const next = [...current, ...toAdd].sort(sortByDateChrono);
  writeJson(mergedPath, next);
  console.log(
    `Merged ${toAdd.length} new episodes from TVDB into src/merged_hot_ones.json (regulars + specials)`
  );
}

main();
